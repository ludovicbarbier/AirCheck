<!doctype html>
<html class="no-js" lang="" style="height: 100%;">
<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<title>AirCheck</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="apple-touch-icon" href="apple-touch-icon.png">
	<!-- Place favicon.ico in the root directory -->

	<link rel="stylesheet" href="css/normalize.css">
	<link rel="stylesheet" href="css/main.css">
	<link rel="stylesheet" href="css/ol.css" type="text/css">
	<script src="js/ol.js"></script>
	<script src="js/vendor/modernizr-2.8.3.min.js"></script>
</head>
<body style="height: 100%;">
<!--[if lt IE 8]>
<p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade
	your browser</a> to improve your experience.</p>
<![endif]-->

<section id="controls">

</section>
<section id="map" class="map" style="width: 100%; height: 100%;"></section>


<script src="js/vendor/jquery-1.12.0.min.js"></script>
<script src="js/plugins.js"></script>
<script src="js/main.js"></script>
<script>


	//		var symptomFill = new ol.style.Fill({
	//			color: 'rgba(255, 0, 0, 0.8)'
	//		});
	//		var symptomStroke = new ol.style.Stroke({
	//			color: 'rgba(255, 0, 0, 0.2)',
	//			width: 1
	//		});
	//		var textFill = new ol.style.Fill({
	//			color: '#fff'
	//		});
	//		var textStroke = new ol.style.Stroke({
	//			color: 'rgba(0, 0, 0, 0.6)',
	//			width: 3
	//		});
	//		var invisibleFill = new ol.style.Fill({
	//			color: 'rgba(255, 255, 255, 0.01)'
	//		});
	//
	//		function createSymptomStyle(feature) {
	//			// 2012_Earthquakes_Mag5.kml stores the magnitude of each symptom in a
	//			// standards-violating <magnitude> tag in each Placemark.  We extract it
	//			// from the Placemark's name instead.
	////			var name = feature.get('name');
	////			console.log(feature);
	////			var magnitude = parseFloat(name.substr(2));
	////			var radius = 20 * (magnitude - 5);
	//
	//			return new ol.style.Style({
	//				geometry: feature.getGeometry(),
	//				image: new ol.style.Circle({
	//					radius: 10,
	//					stroke: new ol.style.Stroke({
	//						color: '#fff'
	//					}),
	//					fill: new ol.style.Fill({
	//						color: '#f00'
	//					})
	//				})
	//			});
	//		}
	//
	//		var maxFeatureCount;
	//		function calculateClusterInfo(resolution) {
	//			maxFeatureCount = 0;
	//			var features = symptomLayer.getSource().getFeatures();
	//			console.log(features);
	//			var feature, radius;
	//			for (var i = features.length - 1; i >= 0; --i) {
	//				feature = features[i];
	//				var originalFeatures = feature.get('features');
	//				var extent = ol.extent.createEmpty();
	//				var j, jj;
	//				for (j = 0, jj = originalFeatures.length; j < jj; ++j) {
	//					ol.extent.extend(extent, originalFeatures[j].getGeometry().getExtent());
	//				}
	//				maxFeatureCount = Math.max(maxFeatureCount, jj);
	//				radius = 0.25 * (ol.extent.getWidth(extent) + ol.extent.getHeight(extent)) /
	//						resolution;
	//				feature.set('radius', radius);
	//			}
	//		}
	//
	//		var currentResolution;
	//		function styleFunction(feature, resolution) {
	//			if (resolution != currentResolution) {
	//				calculateClusterInfo(resolution);
	//				currentResolution = resolution;
	//			}
	//			var style;
	//			var size = feature.get('features').length;
	//			if (size > 1) {
	//				style = new ol.style.Style({
	//					image: new ol.style.Circle({
	//						radius: feature.get('radius'),
	//						fill: new ol.style.Fill({
	//							color: [255, 0, 0, Math.min(0.8, 0.4 + (size / maxFeatureCount))]
	//						})
	//					}),
	//					text: new ol.style.Text({
	//						text: size.toString(),
	//						fill: textFill,
	//						stroke: textStroke
	//					})
	//				});
	//			} else {
	//				var originalFeature = feature.get('features')[0];
	//				style = createSymptomStyle(originalFeature);
	//			}
	//			return style;
	//		}
	//
	//		function selectStyleFunction(feature) {
	//			var styles = [new ol.style.Style({
	//				image: new ol.style.Circle({
	//					radius: feature.get('radius'),
	//					fill: invisibleFill
	//				})
	//			})];
	//			var originalFeatures = feature.get('features');
	//			var originalFeature;
	//			for (var i = originalFeatures.length - 1; i >= 0; --i) {
	//				originalFeature = originalFeatures[i];
	//				styles.push(createSymptomStyle(originalFeature));
	//			}
	//			return styles;
	//		}
	//
	//		var symptomLayer = new ol.layer.Vector({
	//			source: new ol.source.Cluster({
	//				distance: 40,
	//				source: new ol.source.Vector({
	//					url: 'sample/fire.kml',
	//					format: new ol.format.KML({
	//						extractStyles: false
	//					})
	//				})
	//			}),
	//			style: styleFunction
	//		});

	// TODO: This can be removed once we have some real data

	/*
	 Symptom source
	 */
	var count = 20000;
	var features = new Array(count);
	var e = 4500000;
	for (var i = 0; i < count; ++i) {
		var coordinates = [2 * e * Math.random() - e, 2 * e * Math.random() - e];
		features[i] = new ol.Feature(new ol.geom.Point(coordinates));
	}

	var source = new ol.source.Vector({
		features: features
	});

	symptomLayer = new ol.layer.Vector({
		source: new ol.source.Cluster({
			distance: 40,
			source: source
		}),
		style: function (feature, resolution) {
			var size = feature.get('features').length;
			var style = styleCache[size];
			if (!style) {
				style = [new ol.style.Style({
					image: new ol.style.Circle({
						radius: 10,
						stroke: new ol.style.Stroke({
							color: '#fff'
						}),
						fill: new ol.style.Fill({
							color: '#3399CC'
						})
					}),
					text: new ol.style.Text({
						text: size.toString(),
						fill: new ol.style.Fill({
							color: '#fff'
						})
					})
				})];
				styleCache[size] = style;
			}
			return style;
		}
	});


	var clusterSource = new ol.source.Cluster({
		distance: 40,
		source: source
	});

	var styleCache = {};
	var clusters = new ol.layer.Vector({
		source: clusterSource,
		style: function (feature, resolution) {
			var size = feature.get('features').length;
			var style = styleCache[size];
			if (!style) {
				style = [new ol.style.Style({
					image: new ol.style.Circle({
						radius: 10,
						stroke: new ol.style.Stroke({
							color: '#fff'
						}),
						fill: new ol.style.Fill({
							color: '#3399CC'
						})
					}),
					text: new ol.style.Text({
						text: size.toString(),
						fill: new ol.style.Fill({
							color: '#fff'
						})
					})
				})];
				styleCache[size] = style;
			}
			return style;
		}
	});
	clusters.setZIndex(999);

	/*
	 WMTS source
	 */
	var mapSource = new ol.source.WMTS({
		url: "//map1{a-c}.vis.earthdata.nasa.gov/wmts-geo/wmts.cgi?TIME=2013-06-16",
		layer: "MODIS_Terra_CorrectedReflectance_TrueColor",
		format: "image/jpeg",
		matrixSet: "EPSG4326_250m",
		projection: ol.proj.get("EPSG:4326"),
		tileGrid: new ol.tilegrid.WMTS({
			origin: [-180, 90],
			resolutions: [
				0.5625,
				0.28125,
				0.140625,
				0.0703125,
				0.03515625,
				0.017578125,
				0.0087890625,
				0.00439453125,
				0.002197265625
			],
			matrixIds: [0, 1, 2, 3, 4, 5, 6, 7, 8],
			tileSize: 512
		})
	});

	var mapLayer = new ol.layer.Tile({
		source: mapSource
	});
	mapLayer.setZIndex(1);

	/*
	 KML source for earthdata
	 */

	var earthdata = new ol.layer.Vector({
		source: new ol.source.Vector({
			url: 'https://firms.modaps.eosdis.nasa.gov/active_fire/c6/kml/MODIS_C6_Australia_and_New_Zealand_24h.kml',
			format: new ol.format.KML()
		})
	});
	earthdata.setZIndex(100);

	/*
	 Get user location
	 */
	var myLat = 0;
	var myLng = 0;
	function getLocation() {
		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(showPosition);
		} else {
			alert("This application is not supported by this browser.");
		}
	}

	function showPosition(position) {
		myLat = position.coords.latitude;
		myLng = position.coords.longitude;
		console.log(myLat + " " + myLng);
		var map = new ol.Map({
			layers: [mapLayer, clusters],
			target: 'map',
			view: new ol.View({
				center: [position.coords.longitude, position.coords.latitude],
				zoom: 4
			}),
			renderer: ["canvas", "dom"]
		});

	}
	getLocation();


</script>
</body>
</html>
